/*
* <<1. 소켓에 할당되는 IP 주소와 PORT 번호>>
* IP는 Internet Protocol의 약자로 인터넷 상에서 데이터를 송수신할 목적으로 컴퓨터에게 부여되는 값을 의미한다.
* PORT 번호는 컴퓨터에게 부여하는 값이 아닌, 프로그램 상에서 소켓을 구분하기 위해 소켓에 부여되는 번호를 뜻한다.
* 
* 1. 인터넷 주소
* 인터넷에 컴퓨터를 연결해서 데이터를 주고받기 위해서는 IP 주소를 부여 받아야 한다. 이러한 IP 주소에는 다음과 같이 두 종류로 나뉜다.
* 1) IPv4 4바이트 주소 체계
* 2) IPv6 16바이트 주소 체계
* 오늘날 범용적으로 쓴느 주소 체계는 1번 이므로 다른 것은 신경쓰지 않아도 좋다.
* IPv4 기준의 4바이트 IP 주소는 네트워크 주소와 호스트(컴퓨터) 주소로 나뉘고, 주소에 따라 A, B, C, D, E 클래스로 분류된다.
* 네트워크 주소란 네트워크를 구분하기 위한 IP 주소의 일부를 뜻한다. 여기서 네트워크는 라우터의 주소라고 봐도 무방하다.
* 호스트 주소는 실제 컴퓨터의 주소이다.
* 
* 2. 클래스 별 네트워크 주소와 호스트 주소의 경계
* IP 주소의 첫 번째 바이트만 딱 보면 네트워크 주소가 몇 바이트인지 판단이 가능하다. 왜냐하면, 다음과 같이 클래스 별 IP 주소의 경계를 나눴기 때문이다.
* 1) 클래스 A의 첫 번째 바이트 범위 0 ~ 127
* 2) 클래스 B의 첫 번째 바이트 범위 128 ~ 191
* 3) 클래스 C의 첫 번째 바이트 범위 192 ~ 223
* 이러한 기준이 정해져 있기 때문에, 소켓을 통해서 데이터를 송수신할 때, 우리가 별도로 신경쓰지 않아도 네트워크로 데이터가 이동하고 호스트로 전송된다.
* 
* 3. 소켓의 구분에 활용되는 포트 번호
* IP는 컴퓨터를 구분하기 위한 목적이고, PORT 번호는 하나의 운영체제 내에 소켓을 구분하기 위한 목적이다.
* PORT 번호의 범위는 0 ~ 65535이다. 그러나 0 ~ 1023은 well-known port라고 해서 예약되어 있기 떄문에 실제로 사용할 때는 이 범위 외의 번호를 사용해야 한다.
* 
* <<2. 주소 정보의 표현>>
* 응용 프로그램 상에서 IP 주소와 PORT 번호 표현을 위한 구조체가 정의되어 있다. 따라서 이 구조체를 중심으로 목적지 주소의 표현 방법에 대해 살펴보겠다.
* 
* 1. IPv4 기반의 주소 표현을 위한 구조체
* 주소 정보를 담을 때에는 다음 세 가지의 정보를 포함해야 한다.
* 1) 어떠한 주소체계를 사용하는가?
* 2) IP 주소가 어떻게 되는가?
* 3) PORT 번호가 어떻게 되는가?
* 
* 그리하여 위의 정보를 담을 수 있는 구조체가 다음의 형태로 정의되어 있다.
* struct sockaddr_in{
*	sa_famility_t	sin_famility;	// 주소 체계
*	uint16_t		sin_port;		// 포트 번호
*	struct in_addr	sin_addr;		// IP 주소 구조체
*	char			sin_zero[8];	// 사용 안함
* }
* 
* struct in_addr{
*	in_addr_t		s_addr;			// IP 주소
* }
* 
* 2. 구조체 sockaddr_in의 멤버에 대한 분석
* 1) sin_familiy	: 앞에서 배운 주소 체계이다.
* 2) sin_port		: 네트워크 바이트 순서로 포트 번호를 넣는다.
* 3) sin_addr		: 네트워크 바이트 순서로 IP 주소를 넣는다.
* 4) sin_zero		: 의미 없다.
* 
* <<3. 네트워크 바이트 순서와 인터넷 주소 변환>>
* CPU에 따라서 4 바이트 정수 1을 메모리 공간에 저장하는 방식이 달라진다.
* 00000000 00000000 00000000 00000001
* 00000001 00000000 00000000 00000000
* 때문에 이러한 부분을 고려하지 않고 데이터를 송수신하면 문제가 발생할 수 있다.
* 
* 1. 바이트 순서와 네트워크 바이트 순서
* CPU가 데이터를 저장하는 방식은 다음과 같이 두 가지로 나뉜다.
* 1) Big Endian
* 2) Little Endian
* 그래서 CPU의 데이터 저장 방식을 의미하는 '호스트 바이트 순서'는 CPU에 따라 차이가 난다.
* 그래서 네트워크를 통해서 데이터를 전송할 때는 통일된 기준으로 전송하기로 약속했으며, 이를 '네트워크 바이트 순서'라고 한다.
* "빅 엔디안으로 통일합시다"
* 
* 2. 바이트 순서 변환
* 바이트 순서 변환을 돕는 함수를 소개하겠다.
* unsigned short htons(unsigned short);
* unsigned short ntohs(unsigned short);
* unsigned long htonl(unsigned long);
* unsigned long ntohl(unsigned long);
* 
* <<4. 인터넷 주소의 초기화와 할당>>
* 1. 문자열 정보를 네트워크 바이트 순서의 정수로 변환하기
* 문자열로 표현된 IP 주소를 네트워크 바이트 순서의 정수로 변환하는 함수가 있다. 매우 편리하다고 볼 수 있다.
* in_addr_t inet_addr(const char* string);
* 
* 2. 인터넷 주소의 초기화
* 지금까지 배운 것을 토대로 인터넷 주소를 초기화 해보자.
* sockaddr_in addr;
* char* addr_ip = "211.217.168.13";
* char* addr_port = "9190";
* 
* memset(&addr, 0, sizeof(addr));
* addr.sin_familiy = AF_INET;
* addr.sin_port = htons(atoi(addr_port));
* addr.sin_addr.s_addr = inet_addr(addr_ip);
* 
* 3. 클라이언트 주소정보 초기화
* 
* 4. INADDR_ANY
* 컴퓨터의 IP주소를 32비트 정수 형태로 정의한 매크로이다.
* 
* 5. 소켓에 인터넷 주소 할당하기.
* 
* 6. WSAStringToAddress & WSAAddressToString
* 이 둘은 inet_ntoa, inet_addr 함수와 기능이 같으나, 다양한 프로토콜에 적용이 가능하다.
*/